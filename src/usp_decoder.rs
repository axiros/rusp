use anyhow::{anyhow, Context, Result};
use quick_protobuf::message::MessageRead;
use quick_protobuf::BytesReader;

use crate::usp::{self, Error, Msg, Notify};
use crate::usp_record::mod_Record::OneOfrecord_type;
use crate::usp_record::{NoSessionContextRecord, Record};

/// Decodes a slice of bytes containing a Protobuf encoded USP Record into a Record structure for
/// further processing
///
/// # Arguments
///
/// * `bytes` - A slice of bytes containing the Protobuf encoded USP Record
///
/// # Example
///
/// ```
/// use rusp::usp_decoder::try_decode_record;
/// let record =
///     try_decode_record(&[
///         0x0a, 0x03, 0x31, 0x2e, 0x30, 0x1a, 0x23, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x3a, 0x3a,
///         0x61, 0x78, 0x2d, 0x75, 0x73, 0x70, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2d, 0x6e,
///         0x6f, 0x73, 0x73, 0x6c, 0x2d, 0x77, 0x65, 0x62, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74,
///         0x3a, 0x4d, 0x12, 0x4b, 0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74, 0x10, 0x03,
///         0x12, 0x3f, 0x0a, 0x3d, 0x42, 0x3b, 0x0a, 0x0f, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72,
///         0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x42, 0x28, 0x0a, 0x03, 0x6f,
///         0x75, 0x69, 0x12, 0x0d, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x5f, 0x63, 0x6c,
///         0x61, 0x73, 0x73, 0x1a, 0x0d, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x5f, 0x6e, 0x75,
///         0x6d, 0x62, 0x65, 0x72, 0x22, 0x03, 0x31, 0x2e, 0x30,
///     ]);
/// ```
pub fn try_decode_record(bytes: &[u8]) -> Result<Record> {
    let mut reader = BytesReader::from_bytes(bytes);
    Record::from_reader(&mut reader, bytes).context("while parsing protobuf as USP Record")
}

/// Decodes a slice of bytes containing a Protobuf encoded USP Msg into a Msg structure for further
/// processing
///
/// # Arguments
///
/// * `bytes` - A slice of bytes containing the Protobuf encoded USP Message
///
/// # Example
///
/// ```
/// use rusp::usp_decoder::try_decode_msg;
/// let msg =
///     try_decode_msg(&[
///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
///         0x65, 0x74, 0x65, 0x72
///     ]);
/// ```
pub fn try_decode_msg(bytes: &[u8]) -> Result<Msg> {
    let mut reader = BytesReader::from_bytes(bytes);
    Msg::from_reader(&mut reader, bytes).context("while parsing protobuf as USP Message")
}

/// Implementation of some extension methods for `Msg`s
impl Msg {
    /// Tries to decode a slice of bytes containing a Protobuf encoded USP Message
    ///
    /// This function also performs additional checks required by the USP specification, see also
    /// [`Msg::check_validity`]
    ///
    /// # Arguments
    ///
    /// * `bytes` - A slice of bytes containing the Protobuf encoded USP Message
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp::Msg;
    /// let msg =
    ///     Msg::from_bytes(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ])
    ///     .unwrap();
    /// ```
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        let this = try_decode_msg(bytes)?;
        this.check_validity()?;
        Ok(this)
    }

    /// Retrieves the message ID from a Msg structure
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]);
    /// assert_eq!(msg.unwrap().msg_id(), "AXSS-1544114045.442596");
    /// ```
    #[must_use]
    pub fn msg_id(&self) -> &str {
        self.header
            .as_ref()
            .map_or("", |header| header.msg_id.as_ref())
    }

    /// Checks whether the body contains a message of type request
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
    ///         0x10, 0x03, 0x12, 0x28, 0x0a, 0x26, 0x42, 0x24,
    ///         0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x10,
    ///         0x01, 0x42, 0x19, 0x0a, 0x06, 0x30, 0x30, 0x34,
    ///         0x34, 0x46, 0x46, 0x12, 0x03, 0x46, 0x6f, 0x6f,
    ///         0x1a, 0x05, 0x30, 0x31, 0x32, 0x33, 0x34, 0x22,
    ///         0x03, 0x31, 0x2e, 0x33,
    ///     ]).unwrap();
    /// assert_eq!(msg.is_request(), true);
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]).unwrap();
    /// assert_eq!(msg.is_request(), false);
    /// ```
    #[must_use]
    pub const fn is_request(&self) -> bool {
        if let Some(body) = self.body.as_ref() {
            matches!(&body.msg_body, usp::mod_Body::OneOfmsg_body::request(_))
        } else {
            false
        }
    }

    /// Checks whether the body contains a message of type notify (request)
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
    ///         0x10, 0x03, 0x12, 0x28, 0x0a, 0x26, 0x42, 0x24,
    ///         0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x10,
    ///         0x01, 0x42, 0x19, 0x0a, 0x06, 0x30, 0x30, 0x34,
    ///         0x34, 0x46, 0x46, 0x12, 0x03, 0x46, 0x6f, 0x6f,
    ///         0x1a, 0x05, 0x30, 0x31, 0x32, 0x33, 0x34, 0x22,
    ///         0x03, 0x31, 0x2e, 0x33,
    ///     ]).unwrap();
    /// assert_eq!(msg.is_notify_request(), true);
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]).unwrap();
    /// assert_eq!(msg.is_notify_request(), false);
    /// ```
    #[must_use]
    pub const fn is_notify_request(&self) -> bool {
        self.get_notify_request().is_some()
    }

    /// Retrieves the notify request from the Msg
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
    ///         0x10, 0x03, 0x12, 0x28, 0x0a, 0x26, 0x42, 0x24,
    ///         0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x10,
    ///         0x01, 0x42, 0x19, 0x0a, 0x06, 0x30, 0x30, 0x34,
    ///         0x34, 0x46, 0x46, 0x12, 0x03, 0x46, 0x6f, 0x6f,
    ///         0x1a, 0x05, 0x30, 0x31, 0x32, 0x33, 0x34, 0x22,
    ///         0x03, 0x31, 0x2e, 0x33,
    ///     ]).unwrap();
    /// assert!(msg.get_notify_request().is_some());
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]).unwrap();
    /// assert!(msg.get_notify_request().is_none());
    /// ```
    #[must_use]
    pub const fn get_notify_request(&self) -> Option<&Notify> {
        if let Some(body) = self.body.as_ref() {
            if let usp::mod_Body::OneOfmsg_body::request(request) = &body.msg_body {
                if let usp::mod_Request::OneOfreq_type::notify(notify) = &request.req_type {
                    return Some(notify);
                }
            }
        }

        None
    }

    /// Checks whether the body contains a message of type response
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
    ///         0x10, 0x03, 0x12, 0x28, 0x0a, 0x26, 0x42, 0x24,
    ///         0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x10,
    ///         0x01, 0x42, 0x19, 0x0a, 0x06, 0x30, 0x30, 0x34,
    ///         0x34, 0x46, 0x46, 0x12, 0x03, 0x46, 0x6f, 0x6f,
    ///         0x1a, 0x05, 0x30, 0x31, 0x32, 0x33, 0x34, 0x22,
    ///         0x03, 0x31, 0x2e, 0x33,
    ///     ]).unwrap();
    /// assert_eq!(msg.is_response(), false);
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]).unwrap();
    /// assert_eq!(msg.is_response(), true);
    /// ```
    #[must_use]
    pub const fn is_response(&self) -> bool {
        if let Some(body) = self.body.as_ref() {
            matches!(&body.msg_body, usp::mod_Body::OneOfmsg_body::response(_))
        } else {
            false
        }
    }

    /// Checks whether the body contains a message of type response
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
    ///         0x10, 0x03, 0x12, 0x28, 0x0a, 0x26, 0x42, 0x24,
    ///         0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x10,
    ///         0x01, 0x42, 0x19, 0x0a, 0x06, 0x30, 0x30, 0x34,
    ///         0x34, 0x46, 0x46, 0x12, 0x03, 0x46, 0x6f, 0x6f,
    ///         0x1a, 0x05, 0x30, 0x31, 0x32, 0x33, 0x34, 0x22,
    ///         0x03, 0x31, 0x2e, 0x33,
    ///     ]).unwrap();
    /// assert_eq!(msg.is_error(), false);
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]).unwrap();
    /// assert_eq!(msg.is_error(), false);
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x05, 0x0a, 0x03, 0x65, 0x72, 0x72, 0x12,
    ///         0x17, 0x1a, 0x15, 0x0d, 0x5b, 0x1b, 0x00, 0x00,
    ///         0x12, 0x0e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,
    ///         0x61, 0x6c, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72,
    ///     ]).unwrap();
    /// assert_eq!(msg.is_error(), true);
    /// ```
    #[must_use]
    pub fn is_error(&self) -> bool {
        self.get_error().is_some()
    }

    /// Retrieves the notify request from the Msg
    ///
    /// # Arguments
    ///
    /// * `self` - A decoded USP Msg structure
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x08, 0x0a, 0x04, 0x74, 0x65, 0x73, 0x74,
    ///         0x10, 0x03, 0x12, 0x28, 0x0a, 0x26, 0x42, 0x24,
    ///         0x0a, 0x05, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x10,
    ///         0x01, 0x42, 0x19, 0x0a, 0x06, 0x30, 0x30, 0x34,
    ///         0x34, 0x46, 0x46, 0x12, 0x03, 0x46, 0x6f, 0x6f,
    ///         0x1a, 0x05, 0x30, 0x31, 0x32, 0x33, 0x34, 0x22,
    ///         0x03, 0x31, 0x2e, 0x33,
    ///     ]).unwrap();
    /// assert!(msg.get_error().is_none());
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x1a, 0x0a, 0x16, 0x41, 0x58, 0x53, 0x53, 0x2d, 0x31, 0x35, 0x34,
    ///         0x34, 0x31, 0x31, 0x34, 0x30, 0x34, 0x35, 0x2e, 0x34, 0x34, 0x32, 0x35,
    ///         0x39, 0x36, 0x10, 0x02, 0x12, 0x46, 0x12, 0x44, 0x0a, 0x42, 0x0a, 0x40,
    ///         0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x4c, 0x6f, 0x63,
    ///         0x61, 0x6c, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x4d, 0x54, 0x50, 0x2e,
    ///         0x31, 0x2e, 0x57, 0x65, 0x62, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e,
    ///         0x15, 0x62, 0x1b, 0x00, 0x00, 0x1a, 0x15, 0x55, 0x6e, 0x73, 0x75, 0x70,
    ///         0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d,
    ///         0x65, 0x74, 0x65, 0x72
    ///     ]).unwrap();
    /// assert!(msg.get_error().is_none());
    /// ```
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x05, 0x0a, 0x03, 0x65, 0x72, 0x72, 0x12,
    ///         0x17, 0x1a, 0x15, 0x0d, 0x5b, 0x1b, 0x00, 0x00,
    ///         0x12, 0x0e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e,
    ///         0x61, 0x6c, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72,
    ///     ]).unwrap();
    /// assert!(msg.get_error().is_some());
    /// ```
    #[must_use]
    pub fn get_error(&self) -> Option<Error> {
        if let Some(body) = self.body.as_ref() {
            if let usp::mod_Body::OneOfmsg_body::error(error) = &body.msg_body {
                return Some(error.clone());
            }
        }

        None
    }

    /// Checks the validity of this [`Msg`] according to the USP specification
    ///
    /// Although the type itself guarantees its validity against the protobuf schema, the USP
    /// specification places additional constrains on the values used
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_msg;
    /// let msg =
    ///     try_decode_msg(&[
    ///         0x0a, 0x09, 0x0a, 0x07, 0x6e, 0x6f, 0x2d, 0x62,
    ///         0x6f, 0x64, 0x79, 0x12, 0x00,
    ///     ]).unwrap();
    /// assert!(msg.check_validity().is_err());
    /// ```
    pub fn check_validity(&self) -> Result<()> {
        use crate::usp::mod_Body::OneOfmsg_body;
        use crate::usp::mod_Request::OneOfreq_type;
        use crate::usp::mod_Response::OneOfresp_type;
        use crate::usp::{Request, Response};

        self.header
            .as_ref()
            .filter(|h| !h.msg_id.is_empty())
            .ok_or_else(|| anyhow!("Empty message ID"))?;

        let body = self
            .body
            .as_ref()
            .filter(|b| !matches!(b.msg_body, OneOfmsg_body::None))
            .ok_or_else(|| anyhow!("Invalid message body"))?;

        match body.msg_body {
            OneOfmsg_body::request(Request {
                req_type: OneOfreq_type::None,
            }) => Err(anyhow!("Invalid Request message")),
            OneOfmsg_body::response(Response {
                resp_type: OneOfresp_type::None,
            }) => Err(anyhow!("Invalid Response message")),
            _ => Ok(()),
        }
    }
}

impl Record {
    /// Tries to decode a slice of bytes containing a Protobuf encoded USP Record
    ///
    /// This function also performs additional checks required by the USP specification, see also
    /// [`Record::check_validity`]
    ///
    /// # Arguments
    ///
    /// * `bytes` - A slice of bytes containing the Protobuf encoded USP Record
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_record::Record;
    /// let record =
    ///     Record::from_bytes(&[
    ///         0x0a, 0x03, 0x31, 0x2e, 0x33, 0x12, 0x07, 0x64,
    ///         0x6f, 0x63, 0x3a, 0x3a, 0x74, 0x6f, 0x1a, 0x09,
    ///         0x64, 0x6f, 0x63, 0x3a, 0x3a, 0x66, 0x72, 0x6f,
    ///         0x6d, 0x3a, 0x35, 0x12, 0x33, 0x0a, 0x07, 0x0a,
    ///         0x03, 0x67, 0x65, 0x74, 0x10, 0x01, 0x12, 0x28,
    ///         0x0a, 0x26, 0x0a, 0x24, 0x0a, 0x22, 0x44, 0x65,
    ///         0x76, 0x69, 0x63, 0x65, 0x2e, 0x44, 0x65, 0x76,
    ///         0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x2e,
    ///         0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65,
    ///         0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e,
    ///     ])
    ///     .unwrap();
    /// ```
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        let this = try_decode_record(bytes)?;
        this.check_validity()?;
        Ok(this)
    }
    /// Checks the validity of this [`Record`] according to the USP specification
    ///
    /// Although the type itself guarantees its validity against the protobuf schema, the USP
    /// specification places additional constrains on the values used
    ///
    /// # Example
    ///
    /// ```
    /// use rusp::usp_decoder::try_decode_record;
    /// let no_session_empty_payload =
    ///     try_decode_record(&[
    ///         0x0a, 0x03, 0x31, 0x2e, 0x33, 0x12, 0x07, 0x64,
    ///         0x6f, 0x63, 0x3a, 0x3a, 0x74, 0x6f, 0x1a, 0x09,
    ///         0x64, 0x6f, 0x63, 0x3a, 0x3a, 0x66, 0x72, 0x6f,
    ///         0x6d, 0x3a, 0x00,
    ///     ]).unwrap();
    /// assert!(no_session_empty_payload.check_validity().is_err());
    /// ```
    pub fn check_validity(&self) -> Result<()> {
        if self.version.is_empty() {
            return Err(anyhow!("Invalid USP version"));
        }

        if self.to_id.is_empty() {
            return Err(anyhow!("Invalid to_id field in Record"));
        }
        if self.from_id.is_empty() {
            return Err(anyhow!("Invalid from_id field in Record"));
        }

        match &self.record_type {
            OneOfrecord_type::None => Err(anyhow!("Invalid Record type")),
            OneOfrecord_type::no_session_context(NoSessionContextRecord { payload })
                if payload.is_empty() =>
            {
                Err(anyhow!(
                    "NoSessionContext Record containing an empty payload"
                ))
            }
            _ => Ok(()),
        }
    }

    /// Flattens the payload of the [`Record`] and returns a mutable reference to it
    ///
    /// This function will return [`None`] for both empty payloads and Record types that do not
    /// contain a payload
    pub fn payload_flatten(&mut self) -> Option<&mut Vec<u8>> {
        use crate::usp_record::mod_Record::OneOfrecord_type;
        use std::mem;

        let flatten = match &mut self.record_type {
            OneOfrecord_type::no_session_context(no_session) => Some(&mut no_session.payload),
            OneOfrecord_type::session_context(session) => {
                let flatten = if session.payload.len() == 1 {
                    &mut session.payload[0]
                } else {
                    let old = mem::take(&mut session.payload);
                    session.payload = vec![old.into_iter().flatten().collect()];
                    &mut session.payload[0]
                };
                Some(flatten)
            }
            _ => None,
        };
        flatten.filter(|p| !p.is_empty())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn empty_msg_id() {
        let raw = [
            0x0a, 0x02, 0x10, 0x01, 0x12, 0x28, 0x0a, 0x26, 0x0a, 0x24, 0x0a, 0x22, 0x44, 0x65,
            0x76, 0x69, 0x63, 0x65, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66,
            0x6f, 0x2e, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73,
            0x69, 0x6f, 0x6e, 0x2e,
        ];
        let msg = try_decode_msg(&raw)
            .expect("raw should be a valid USP Message according to the protobuf schema");
        assert!(msg.check_validity().is_err());
    }

    #[test]
    fn invalid_record_to_id() {
        let raw = [
            0x0a, 0x03, 0x31, 0x2e, 0x33, 0x1a, 0x09, 0x64, 0x6f, 0x63, 0x3a, 0x3a, 0x66, 0x72,
            0x6f, 0x6d, 0x3a, 0x35, 0x12, 0x33, 0x0a, 0x07, 0x0a, 0x03, 0x67, 0x65, 0x74, 0x10,
            0x01, 0x12, 0x28, 0x0a, 0x26, 0x0a, 0x24, 0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63,
            0x65, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x53,
            0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
            0x2e,
        ];
        let record = try_decode_record(&raw)
            .expect("raw should be a valid Record according to the protobuf schema");
        assert!(record.check_validity().is_err());

        let OneOfrecord_type::no_session_context(NoSessionContextRecord { payload: msg_raw }) =
            record.record_type
        else {
            panic!("Record should have a NoSessionContext type");
        };

        let msg = try_decode_msg(&msg_raw)
            .expect("msg_raw should be a valid USP Message according to the protobuf schema");
        msg.check_validity().unwrap();
    }

    #[test]
    fn invalid_record_from_id() {
        let raw = [
            0x0a, 0x03, 0x31, 0x2e, 0x33, 0x12, 0x07, 0x64, 0x6f, 0x63, 0x3a, 0x3a, 0x74, 0x6f,
            0x3a, 0x35, 0x12, 0x33, 0x0a, 0x07, 0x0a, 0x03, 0x67, 0x65, 0x74, 0x10, 0x01, 0x12,
            0x28, 0x0a, 0x26, 0x0a, 0x24, 0x0a, 0x22, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e,
            0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x53, 0x6f, 0x66,
            0x74, 0x77, 0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e,
        ];
        let record = try_decode_record(&raw)
            .expect("raw should be a valid Record according to the protobuf schema");
        assert!(record.check_validity().is_err());

        let OneOfrecord_type::no_session_context(NoSessionContextRecord { payload: msg_raw }) =
            record.record_type
        else {
            panic!("Record should have a NoSessionContext type");
        };

        let msg = try_decode_msg(&msg_raw)
            .expect("msg_raw should be a valid USP Message according to the protobuf schema");
        msg.check_validity().unwrap();
    }

    #[test]
    fn flat_record() {
        use crate::usp_record::mod_Record::OneOfrecord_type;

        let raw = [
            0x0a, 0x03, 0x31, 0x2e, 0x33, 0x12, 0x07, 0x64, 0x6f, 0x63, 0x3a, 0x3a, 0x74, 0x6f,
            0x1a, 0x09, 0x64, 0x6f, 0x63, 0x3a, 0x3a, 0x66, 0x72, 0x6f, 0x6d, 0x42, 0x3c, 0x08,
            0xd2, 0x09, 0x10, 0x01, 0x18, 0x02, 0x3a, 0x33, 0x0a, 0x07, 0x0a, 0x03, 0x67, 0x65,
            0x74, 0x10, 0x01, 0x12, 0x28, 0x0a, 0x26, 0x0a, 0x24, 0x0a, 0x22, 0x44, 0x65, 0x76,
            0x69, 0x63, 0x65, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f,
            0x2e, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69,
            0x6f, 0x6e, 0x2e,
        ];
        let mut record = Record::from_bytes(&raw).expect("raw should be a valid Record");
        let payload = record.payload_flatten().unwrap().clone();
        assert!(!payload.is_empty());

        let splitted = payload.chunks(2).map(Vec::from).collect::<Vec<_>>();
        assert!(splitted.len() > 1);

        let session = match &mut record.record_type {
            OneOfrecord_type::session_context(session) => session,
            _ => {
                panic!("Record should be of type SessionContext");
            }
        };
        session.payload = splitted;

        let flatten = record.payload_flatten().unwrap();
        assert_eq!(flatten, &payload);
    }
}
